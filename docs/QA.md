# Документация на тестването на проекта 

## Въведение

Проектът е написан на езика python. За тестване е използвана библиотеката на python - unittest. Написани са 47 unit-теста, които тестват всички от 9-те пакета. Общият code-coverage постигнат с тези тестове е 90%. 7 от 9-те файла имат 100% code-coverage. Останалите 2 файла имат нетествани методи, но те не се използват никъде и съществуват само за пълнота на API-я на компонентите. Избрали сме да направим white-box testing, защото имаме много междинни, скрити от потребителя състояния, на програмата, които трябва да работят правилно, за да работи и цялата програма. Тъй като сложността е много голяма не може да си позволим да направим само blackbox testing, защото ако има бъг в програмата, ще е много сложно откриването му тъй като някой методи може да извикват 10+ други методи в дълбочина.

Резултат от  тестовете:

https://qa-xml-test-results.netlify.com/

## Начин на създаване на тестовете

Тестовете са написани така че да покрият всички възможни пътища на изпълнение в кода, ако моделираме проекта като граф на функции, методи, класове и if-else блокове. Тестовете надграждат един над друг и тестват вътрешните функционалности една след друга. Под вътрешни функционалности разбираме private/protected методи и функции за даден клас или пакет. Тези методи не са достъпни при нормално използване на софтуера, но за целите на тестване python позволява да се наруши енкапсулацията и да имаме достъп до скрити член данни и функции. Това позволява да проверяваме междинните състояния на програмата. Ако разглеждаме програмата като последователност от функционалности A -> B -> ... , тестовете първо проверяват, че на стъпка A всичко е изпълнено правилно, след това други тестове проверяват междинното състояние на данните на стъпка B и тн. За да се постигне това сме използвали call-stack на функциите, за да определим коя след коя се извиква. Ето няколко примера на call-stack-а на тестове - какви модули използват и коя функция коя друга извиква. Тестовете първо проверяват състоянието на първото ниво (най-горното), след това на второто ниво и тн. Може да се разглежда като обхождане на графа в широчина.

![](https://imgur.com/NrSWhrN.png)

https://imgur.com/OCRNiWV

https://imgur.com/rjh86MX

https://imgur.com/NrSWhrN

## Осигуряване на пълно покритие на входните данни

За да се осигури, че не само сме тествали всички възможни методи в програмата, а и всички възможни входове сме разделили входа на класове на еквивалентност, които да покриват всички възможни входове. Тъй като програмата работи със файлове/стрингове, които трябва да представляват валидни DTD документи, най-общо разделянето на класове на еквивалентност може да е: несъществуващ файл, празен файл, файл с невалидни данни, файл с частично валидни данни, файл с напълно валидни данни. Това разделение важи и когато входа е string, а не файл. Отделно за тестването на функционалности може да разделим тези класове на еквивалентност на още повече класове. Например горните класове на еквивалентност са важни за нас, когато четен файл/стринг и трябва да вземем съдържанието. След като имаме съдържанието и сме проверили, че е валидно, попадаме в случая файл с напълно валидни данни. За да продължим тестването/изпълнението на програмата валидните данни могат да бъдат разделени в смисъла на DTD на 1 елемент, 1 елемент и 1 атрибут, множество елементи, множество елементи и множество атрибути и т.н.

## Осигуряване на пълно покритие на кода

За осигуряване, че максимална част от кода е тестван използвахме coverage.py, за да генерираме информация кои редове от кода са тествани и кои не.

Резултат за финалното покритие на кода с тестове:

https://qa-xml-coverage.netlify.com/

## Заключение

Всички функционалности необходими на проекта да работи и всички функционалности, които проектът използва са тествани. Някой функционалности, които не се използват са оставени нетествани, но те съществуват, за да имат пълнота интерфейсите на софтуера. По този начин постигаме 100% покритие на проекта с тестове и 90% покритие на кода.